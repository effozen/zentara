# 플러그인 시스템

Zentara의 플러그인 시스템을 사용하면 입력 필드의 기능을 다양한 방식으로 확장할 수 있습니다.

## 플러그인 인터페이스

````typescript
interface Plugin<TConfig = unknown> {
  /**
   * 플러그인의 고유 식별자.
   * ZentaraInput 설정에서 플러그인을 식별하는 데 사용되며
   * 모든 플러그인에서 고유해야 합니다.
   *
   * @example
   * ```ts
   * name: 'suggestions'
   * name: 'mentions'
   * name: 'emoji-picker'
   * ```
   */
  name: string;

  /**
   * 플러그인이 처음 마운트될 때 호출되는 초기화 함수.
   * 외부 리소스, 이벤트 리스너 또는 초기 상태를 설정하는 데 사용합니다.
   * 플러그인이 언마운트될 때 호출될 정리 함수를 반환할 수 있습니다.
   *
   * @param context - 현재 입력 상태와 메서드를 포함하는 플러그인 컨텍스트
   * @returns 선택적 정리 함수
   *
   * @example
   * ```ts
   * init: (context) => {
   *   // WebSocket 연결 설정
   *   const ws = new WebSocket('...');
   *   ws.onmessage = (event) => {
   *     // 실시간 업데이트 처리
   *   };
   *
   *   // 정리 함수 반환
   *   return () => {
   *     ws.close();
   *   };
   * }
   * ```
   */
  init?: (context: PluginContext<TConfig>) => void | (() => void);

  /**
   * 입력 값이 변경될 때마다 호출됩니다.
   * 입력 값을 수정하거나 부수 효과를 발생시키는 데 사용합니다.
   * 동기적 또는 비동기적으로 수정된 값을 반환할 수 있습니다.
   *
   * @param value - 현재 입력 값
   * @param context - 플러그인 컨텍스트
   * @returns 수정된 입력 값 (또는 Promise)
   *
   * @example
   * ```ts
   * // 동기적 변환
   * onValueChange: (value) => {
   *   return value.toLowerCase();
   * }
   *
   * // 비동기적 변환
   * onValueChange: async (value, context) => {
   *   const suggestion = await fetchSuggestion(value);
   *   return suggestion;
   * }
   *
   * // 값 수정 없이 부수 효과만
   * onValueChange: (value, context) => {
   *   saveToLocalStorage(value);
   *   return value;
   * }
   * ```
   */
  onValueChange?: (
    value: string,
    context: PluginContext<TConfig>
  ) => string | Promise<string>;

  /**
   * 입력 필드의 모든 keydown 이벤트에서 호출됩니다.
   * 키보드 단축키를 처리하거나 입력 동작을 수정하는 데 사용합니다.
   * event.preventDefault()를 호출하여 기본 브라우저 동작을 방지할 수 있습니다.
   *
   * @param event - 키보드 이벤트
   * @param context - 플러그인 컨텍스트
   *
   * @example
   * ```ts
   * onKeyDown: (event, context) => {
   *   // 키보드 단축키 처리
   *   if (event.ctrlKey && event.key === 'b') {
   *     event.preventDefault();
   *     toggleBold();
   *   }
   *
   *   // 특수 키 처리
   *   if (event.key === 'Tab') {
   *     event.preventDefault();
   *     handleTabCompletion();
   *   }
   *
   *   // 네비게이션
   *   if (event.key === 'ArrowDown') {
   *     event.preventDefault();
   *     selectNextItem();
   *   }
   * }
   * ```
   */
  onKeyDown?: (
    event: KeyboardEvent<HTMLInputElement>,
    context: PluginContext<TConfig>
  ) => void;

  /**
   * 입력 필드 위에 오버레이되는 추가 콘텐츠를 렌더링합니다.
   * 제안, 툴팁 또는 기타 플로팅 UI 요소를 표시하는 데 사용합니다.
   * 오버레이는 입력 요소를 기준으로 위치가 지정됩니다.
   *
   * @param context - 플러그인 컨텍스트
   * @returns 오버레이로 렌더링할 React 노드
   *
   * @example
   * ```tsx
   * renderOverlay: (context) => {
   *   const state = stateManager.usePluginState();
   *
   *   if (!state.isOpen) return null;
   *
   *   return (
   *     <Portal>
   *       <div className="overlay">
   *         {state.items.map(item => (
   *           <Item
   *             key={item.id}
   *             item={item}
   *             onClick={() => selectItem(item)}
   *           />
   *         ))}
   *       </div>
   *     </Portal>
   *   );
   * }
   * ```
   */
  renderOverlay?: (context: PluginContext<TConfig>) => ReactNode;

  /**
   * 기본 입력 컴포넌트 대신 커스텀 입력 컴포넌트를 렌더링합니다.
   * 입력 필드의 외관과 동작을 완전히 커스터마이징하는 데 사용합니다.
   * 핵심 기능을 유지하기 위해 모든 필요한 props를 전달해야 합니다.
   *
   * @param props - 기능 유지를 위해 전달해야 하는 props
   * @returns 커스텀 입력 컴포넌트
   *
   * @example
   * ```tsx
   * renderInput: (props) => {
   *   return (
   *     <div className="custom-input-wrapper">
   *       <input
   *         {...props}
   *         className={clsx(props.className, 'custom-input')}
   *       />
   *       <div className="custom-decorations">
   *         [여기에 커스텀 장식이 렌더링됩니다]
   *       </div>
   *     </div>
   *   );
   * }
   * ```
   */
  renderInput?: (props: InputRenderProps<TConfig>) => ReactNode;

  /**
   * 플러그인이 언마운트될 때 호출되는 정리 메서드.
   * 리소스, 구독 또는 부수 효과를 정리하는 데 사용합니다.
   * 이는 init의 정리와는 다르며, 플러그인 자체가 **제거**될 때 호출됩니다.
   * 따라서 이 메서드를 사용하여 리소스를 영구적으로 정리하는 것이 좋습니다.
   *
   * @example
   * ```ts
   * destroy: () => {
   *   // 리소스 정리
   *   websocket.close();
   *   document.removeEventListener('click', handler);
   *   clearInterval(interval);
   *
   *   // 캐시 정리
   *   localStorage.removeItem('plugin-cache');
   * }
   * ```
   */
  destroy?: () => void;
}
````

## 플러그인 만들기

다음은 텍스트를 대문자로 변환하는 간단한 플러그인의 예시입니다:

```typescript
import { createPluginFactory } from '@zentara/core';

interface MyPluginState {
  count: number;
}

const uppercasePlugin = createPluginFactory<MyPluginState>()({
  initialState: {
    count: 0,
  },
  createPlugin: (stateManager) => ({
    name: 'uppercase',
    onValueChange: (value) => value.toUpperCase(),
  }),
});
```

## 플러그인 생명주기

### 초기화

`init` 메서드는 플러그인이 마운트될 때 호출됩니다. 선택적으로 정리 함수를 반환할 수 있습니다:

```typescript
init: (context) => {
  console.log('플러그인 초기화됨');

  // 선택적 정리 함수
  return () => {
    console.log('init에서의 정리 작업');
  };
};
```

### 제거

`destroy` 메서드는 플러그인이 완전히 제거될 때 호출됩니다:

```typescript
destroy: () => {
  console.log('플러그인 제거됨');
};
```

## 입력 처리

### 값 변경

`onValueChange` 메서드는 동기적 또는 비동기적으로 값을 반환할 수 있습니다:

```typescript
// 동기적 처리
onValueChange: (value) => {
  return value.toUpperCase();
};

// 비동기적 처리
onValueChange: async (value, context) => {
  const suggestion = await fetchSuggestion(value);
  return suggestion;
};
```

### 키 이벤트

`onKeyDown` 메서드는 키보드 이벤트를 처리합니다:

```typescript
onKeyDown: (event, context) => {
  if (event.key === 'Tab') {
    event.preventDefault();
    // 탭 키 처리
  }
};
```

## 커스텀 UI

### 오버레이 렌더링

`renderOverlay` 메서드를 사용하면 입력 필드 위에 UI 요소를 렌더링할 수 있습니다:

```typescript
renderOverlay: (context) => {
  return <div className='my-overlay'>카운트: {context.shared.count}</div>;
};
```

### 커스텀 입력 필드 렌더링

`renderInput` 메서드를 사용하면 입력 필드를 완전히 커스터마이징할 수 있습니다. 여러 플러그인이 `renderInput`을 제공하는 경우 첫 번째 플러그인의 것만 사용됩니다:

```typescript
renderInput: (props) => {
  return (
    <div className='custom-input-wrapper'>
      <input {...props} />
      <button onClick={() => props.setValue('')}>지우기</button>
    </div>
  );
};
```

## 플러그인 사용하기

```jsx
import { ZentaraInput } from '@zentara/core';

function MyComponent() {
  return <ZentaraInput plugins={[uppercasePlugin()]} />;
}
```

## 플러그인 상태 관리

플러그인은 `createPluginFactory` 유틸리티를 사용하여 상태를 관리할 수 있습니다. 이는 다음과 같은 인터페이스를 제공합니다:

````typescript
interface PluginStateManager<TState> {
  /**
   * 플러그인의 현재 상태를 가져옵니다.
   * 이는 상태 객체를 직접 반환하는 저수준 API입니다.
   * React 컴포넌트에서는 대신 `usePluginState`를 사용하는 것이 좋습니다.
   *
   * @example
   * ```ts
   * // 직접 상태 접근 (저수준)
   * const currentState = stateManager.getState();
   * console.log(currentState.value);
   * ```
   */
  getState: () => TState;

  /**
   * 플러그인 상태를 부분적으로 또는 전체적으로 업데이트합니다.
   * newState 객체에 지정된 속성만 업데이트됩니다.
   * 다른 속성은 현재 값을 유지합니다.
   * 이는 모든 구독자에게 알림을 트리거합니다.
   *
   * @param newState - 업데이트할 속성만 포함하는 부분 상태 객체
   *
   * @example
   * ```ts
   * // 특정 속성 업데이트
   * stateManager.setState({ isOpen: true, selectedIndex: 0 });
   *
   * // 중첩된 속성 업데이트
   * stateManager.setState({
   *   user: { ...currentState.user, name: '새 이름' }
   * });
   * ```
   */
  setState: (newState: Partial<TState>) => void;

  /**
   * 상태 변경을 구독합니다.
   * 이는 주로 비 React 컨텍스트나 내부 구현에 사용되는 저수준 API입니다.
   * React 컴포넌트에서는 구독을 자동으로 처리하는 `usePluginState`를 사용하는 것이 좋습니다.
   *
   * @param callback - 상태가 변경될 때마다 호출될 함수
   * @returns 구독을 정리하기 위해 호출해야 하는 구독 해제 함수
   *
   * @example
   * ```ts
   * // 외부 상태 구독 (비 React)
   * const unsubscribe = stateManager.subscribe(() => {
   *   const newState = stateManager.getState();
   *   console.log('상태 업데이트:', newState);
   * });
   *
   * // 구독 정리
   * unsubscribe();
   *
   * // WebSocket 또는 다른 외부 시스템에서 사용
   * init: () => {
   *   const ws = new WebSocket('...');
   *   const unsubscribe = stateManager.subscribe(() => {
   *     ws.send(JSON.stringify(stateManager.getState()));
   *   });
   *   return () => {
   *     unsubscribe();
   *     ws.close();
   *   };
   * }
   * ```
   */
  subscribe: (callback: () => void) => () => void;

  /**
   * 상태를 초기값으로 재설정합니다.
   * 플러그인이 원래 상태로 돌아가야 할 때 유용합니다.
   * 이는 모든 구독자에게 알림을 트리거합니다.
   *
   * @example
   * ```ts
   * // ESC 키에서 재설정
   * onKeyDown: (event) => {
   *   if (event.key === 'Escape') {
   *     stateManager.reset();
   *   }
   * }
   *
   * // 성공적인 작업 후 재설정
   * onSubmit: async () => {
   *   await saveData();
   *   stateManager.reset();
   * }
   * ```
   */
  reset: () => void;

  /**
   * 플러그인이 사용하는 모든 리소스를 정리합니다.
   * 여기에는 모든 구독 정리와 상태 재설정이 포함됩니다.
   * 플러그인이 언마운트되거나 제거될 때 호출해야 합니다.
   *
   * @example
   * ```ts
   * // React useEffect에서 정리
   * useEffect(() => {
   *   return () => {
   *     stateManager.destroy();
   *   };
   * }, []);
   *
   * // 플러그인 언마운트에서
   * onUnmount: () => {
   *   stateManager.destroy();
   * }
   * ```
   */
  destroy: () => void;

  /**
   * 플러그인 상태 변경을 구독하는 React 훅.
   * React 컴포넌트에서 플러그인 상태에 접근하는 권장 방법입니다.
   * 구독과 정리를 자동으로 처리합니다.
   * 현재 상태를 반환하고 상태가 변경될 때 컴포넌트를 다시 렌더링합니다.
   *
   * @returns 현재 플러그인 상태
   *
   * @example
   * ```tsx
   * function MyComponent() {
   *   // 상태 변경을 자동으로 구독
   *   const state = stateManager.usePluginState();
   *
   *   return (
   *     <div>
   *       {state.isOpen && <Overlay />}
   *       <span>{state.selectedItem?.name}</span>
   *     </div>
   *   );
   * }
   * ```
   */
  usePluginState: () => TState;
}
````
