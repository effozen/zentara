# Creating Plugins

Learn how to create your own plugins for Zentara.

## Basic Structure

Every plugin is created using the `createPluginFactory` function:

```typescript
import { createPluginFactory } from '@zentara/core';

interface MyPluginState {
  count: number;
}

const myPlugin = createPluginFactory<MyPluginState>()({
  initialState: {
    count: 0,
  },
  createPlugin: (stateManager) => ({
    name: 'my-plugin',
    // Plugin methods here
  }),
});
```

## Plugin Lifecycle

### Initialization

The `init` method is called when the plugin is mounted:

```typescript
init: (context) => {
  console.log('Plugin initialized');

  // Return cleanup function (optional)
  return () => {
    console.log('Cleanup from init');
  };
};
```

### Destruction

The `destroy` method is called when the plugin is unmounted:

```typescript
destroy: () => {
  console.log('Plugin destroyed');
};
```

## Handling Input

### Value Changes

The `onValueChange` method is called whenever the input value changes:

```typescript
onValueChange: (value, context) => {
  // Modify the value
  return value.toUpperCase();
};
```

### Key Events

The `onKeyDown` method handles keyboard events:

```typescript
onKeyDown: (event, context) => {
  if (event.key === 'Tab') {
    event.preventDefault();
    // Handle tab key
  }
};
```

## Custom UI

### Overlay Rendering

The `renderOverlay` method allows you to render UI elements above the input:

```tsx
renderOverlay: (context) => {
  return <div className='my-overlay'>Count: {context.shared.count}</div>;
};
```

### Custom Input Rendering

The `renderInput` method allows complete customization of the input field:

```tsx
renderInput: (props) => {
  return (
    <div className='custom-input-wrapper'>
      <input {...props} />
      <button onClick={() => props.setValue('')}>Clear</button>
    </div>
  );
};
```
